---
description:
globs:
alwaysApply: false
---

Part 1: 스마트 컨트랙트 설계 가이드라인 (The 'Lego Brick' Design)
개념: 스마트 컨트랙트 설계는 **"우리가 만들 레고 작품의 최종 모습은 무엇이며, 어떤 부품들로 이루어져 있는가?"**를 정의하는 과정입니다. 코딩 실력보다는 '무엇을 만들고 싶은가'에 대한 명확한 **'기획'**이 더 중요합니다.

1단계: 목표 설정 - '가장 간단한 레고 작품' 정하기
가장 먼저, 우리 빌더가 만들어낼 최종 결과물 중 가장 간단한 것, 즉 MVP(Minimum Viable Product) 버전을 하나 정해야 합니다. 처음부터 우주선을 만들려고 하면 지쳐서 포기하게 됩니다. '바퀴 4개 달린 자동차'부터 시작하는 겁니다.

개념: '요구사항 정의'라고 합니다. 우리 빌더의 첫 번째 목표 작품이 갖춰야 할 기능을 아주 쉬운 말로 나열하는 단계입니다.

액션 (Action):

노트나 메모장을 켭니다.

'내 첫 NFT 작품'이 가져야 할 기능을 글로 적어보세요.

"이름과 심볼을 가질 수 있다."

"오직 나(소유자)만 새로 발행(민팅)할 수 있다."

"만들어진 NFT는 다른 사람에게 보낼 수 있다."

"총 몇 개까지 만들 수 있는지 최대 발행량이 정해져 있다."

이것만으로도 이미 설계의 50%는 끝났습니다.

2단계: '설계도' 그리기 - 목표 컨트랙트 코드 찾아보기
이제 우리가 만들 '바퀴 4개 달린 자동차'의 공식 조립 설명서를 찾아볼 차례입니다. 즉, 1단계에서 정의한 기능을 가진 실제 스마트 컨트랙트 코드는 어떤 모습일지 확인하는 겁니다.

개념: '참조(Reference) 코드 분석'입니다. 이미 잘 만들어진 표준 코드를 보고, 우리 목표가 코드로는 어떻게 표현되는지 이해하는 과정입니다.

액션 (Action):

OpenZeppelin은 스마트 컨트랙트의 '표준 부품 라이브러리'입니다. 여기서 Wizard(https://docs.openzeppelin.com/contracts/5.x/wizard) 서비스에 접속합니다.

왼쪽 옵션에서 ERC721(NFT 표준)을 클릭하고, 오른쪽에 나타나는 옵션들을 1단계에서 정의한 기능에 맞게 체크해 보세요. (Mintable, Ownable, Max Supply 등)

오른쪽 코드 창에 자동으로 생성되는 솔리디티 코드를 복사해서 내 메모장에 붙여넣습니다. 이 코드가 바로 우리가 만들어야 할 **'최종 목표 설계도'**입니다.

3단계: '레고 블록' 식별하기 - 커스터마이징 포인트 찾기
'최종 목표 설계도'를 손에 넣었습니다. 이제 이 설계도에서 사용자가 직접 값을 바꾸거나 기능을 켜고 끌 수 있는 부분, 즉 **'커스터마이징 가능한 레고 블록'**이 무엇인지 찾아내는 단계입니다.

개념: '변수와 기능의 모듈화'입니다. 거대한 코드 덩어리를 작은 기능 단위로 나누고, 어떤 부분을 사용자가 선택할 수 있게 할지 결정하는 과정입니다.

액션 (Action):

2단계에서 복사한 코드를 보며, 사용자가 직접 입력해야 할 부분을 목록으로 만듭니다.

입력값 블록:

Name: "MyEpicNFT" → 사용자가 입력할 '이름'

Symbol: "EPIC" → 사용자가 입력할 '심볼'

MaxSupply: 1000 → 사용자가 입력할 '최대 발행량'

기능 On/Off 블록:

Mintable: "새로 발행하는 기능" (On/Off 가능)

Ownable: "소유자만 제어하는 기능" (On/Off 가능)

Burnable: "NFT를 소각(삭제)하는 기능" (On/Off 가능)

축하합니다! 여기까지 하셨다면 스마트 컨트랙트 설계가 끝났습니다. 우리는 이제 어떤 종류의 '레고 블록'들을 사용자에게 제공해야 하는지 명확한 목록을 갖게 되었습니다.

Part 2: 백엔드 설계 가이드라인 (The 'Instruction Manual & Lego Box' Design)
개념: 백엔드 설계는 **"사용자가 조립판 위에서 선택한 레고 블록들을 어떻게 보관하고, 어떻게 조립 설명서(솔리디티 코드)로 만들어주며, 완성된 작품을 어떻게 블록체인에 등록시켜줄까?"**를 계획하는 과정입니다.

1단계: 역할 정의 - '조력자'로서의 백엔드 이해하기
먼저 백엔드 서버가 블록체인과 어떻게 다른지 명확히 이해해야 합니다.

개념: '시스템 아키텍처'의 기본을 이해하는 단계입니다. 백엔드 서버는 블록체인 밖에 있는 '일반 웹 서버'입니다.

백엔드의 핵심 역할 3가지:

기억하기 🗃️: 사용자가 만들고 있는 레고 작품(프로젝트)의 중간 상태를 데이터베이스에 저장해줍니다. (사용자가 나중에 다시 와서 이어서 작업할 수 있도록)

번역하기 📜: 사용자가 조립한 시각적 블록 정보를 받아, 실제 솔리디티 코드(스마트 컨트랙트 설계도)로 '번역'해줍니다.

등록하기 🤖: 번역된 코드를 블록체인에 배포(등록)하는 복잡한 과정을 대신 처리해줍니다.

2단계: 데이터베이스 설계 - '레고 상자'와 '보관함' 만들기
백엔드가 '기억하기' 역할을 수행하려면 정보를 담을 상자가 필요합니다. 이것이 데이터베이스입니다.

개념: '데이터 모델링'입니다. 어떤 정보를 어떤 구조로 저장할지 표(Table)를 설계하는 과정입니다.

액션 (Action):

가장 핵심적인 보관함 2개를 정의합니다.

Users 테이블 (사용자 보관함): 우리 사이트에 가입한 사용자는 누구인지 기억하는 상자.

필요한 정보: id (고유번호), wallet_address (지갑 주소)

Projects 테이블 (레고 작품 보관함): 사용자가 만들고 있는 개별 작품들을 저장하는 상자.

필요한 정보: id (고유번호), user_id (누가 만들었는지), name (작품 이름), design_data (가장 중요! 사용자가 조립한 레고 블록들의 정보가 담긴 JSON 데이터)

두 테이블의 관계를 이해합니다.

"**한 명의 User**는 **여러 개의 Projects**를 가질 수 있다."

3. API 설계 - '소통 창구' 만들기
   이제 프론트엔드(사용자의 손)가 백엔드(설명서)에게 말을 걸 수 있는 '소통 창구'를 설계합니다.

개념: 'API(Application Programming Interface) 설계'입니다. "이런 주소로 이런 요청을 보내면, 이런 일을 처리해주고 이런 결과를 돌려줄게"라고 약속하는 규칙을 정하는 것입니다.

액션 (Action):

사용자의 행동을 기반으로 필요한 API를 나열해 봅니다.

사용자가 새 프로젝트 만들기 버튼을 누르면?

→ POST /api/projects (새 작품 정보를 보관함에 저장해줘)

사용자가 내 프로젝트 목록 페이지에 들어가면?

→ GET /api/projects (내가 만든 작품 목록 전부 보여줘)

사용자가 저장 버튼을 누르면?

→ PUT /api/projects/:id (이 작품의 최신 상태로 덮어씌워줘)

사용자가 코드 생성 버튼을 누르면?

→ POST /api/projects/:id/generate-code (이 작품의 design_data를 가지고 솔리디티 코드로 번역해줘)
